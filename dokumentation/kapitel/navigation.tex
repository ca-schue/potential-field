\chapter{Roboternavigation im Kraftfeld}

Die Roboternavigation der Potenzialfeldmethode entspricht der Bewegung eines Körpers im \textit{Gravitationsfeld} des Potenzialfelds.

\section{Berechnung der Gradienten}

Das Gravitationsfeld entspricht dem Gradientenfeld des Potenzialfelds: Auf jede Koordinate im Gravitationsfeld wirkt Gravitationskraft zerlegt in die drei kartesische Komponenten des Konfigurationsraums. Jedes dieser drei Kraftfelder $F_{x/y/rotation}(\texttt{x}, \texttt{y}, \texttt{rotation})$ gibt für die jeweilige Dimension des Konfigurationsraums die Größe der Gravitationskraft in der Koordinate (\texttt{x}, \texttt{y}, \texttt{rotation}) an:
\begin{equation*}
 F_{x}(\texttt{x}, \texttt{y}, \texttt{rotation}), F_{y}(\texttt{x}, \texttt{y}, \texttt{rotation}), F_{rotation}(\texttt{x}, \texttt{y}, \texttt{rotation}) = -\nabla U(\texttt{x}, \texttt{y}, \texttt{rotation})
\end{equation*}

Um die Gradienten zwischen dem letzten Rotationsschritt und $0$° zu berechnen, wird die erste und letzte Rotationsebene an das jeweils andere Ende der Dimension \texttt{potential[rotation]} kopiert.
\begin{align*}
	\texttt{first\_layer} & = \texttt{potential[0]} \\
    \texttt{last\_layer} & = \texttt{potential[\texttt{rotations - 1}]} \\
	\texttt{potential\_padded} & = \texttt{np.concatenate([last\_layer, potential, first\_layer], axis=0)}
\end{align*}

Die Gradienten des Potenzialfelds \texttt{potential} werden anschließend mit \texttt{np.gradients()} berechnet:
\begin{equation*}
 \texttt{gradient\_rotation}, \texttt{ gradient\_y}, \texttt{ gradient\_x} = \texttt{np.gradients(potential\_padded)}
\end{equation*}

Die Kraftfelder entsprechen somit den Gradienten werden ohne die kopierten Rotationsebenen:
\begin{align*}
	\texttt{force\_field\_rotation} & = -\texttt{gradient\_rotation[1:rotation-1]} \\
    \texttt{force\_field\_x} & = -\texttt{gradient\_x[1:rotation-1]} \\
	\texttt{force\_field\_y} & = -\texttt{gradient\_y[1:rotation-1]} \\
\end{align*}
Somit entsprechen Gradienten $ \texttt{force\_field\_rotation[rotation]} > 0 $ einer Kraft in Richtung $\texttt{force\_field\_rotation[0]}$ und Gradienten $ \texttt{force\_field\_rotation[0]} < 0 $ einer Kraft in Richtung $\texttt{force\_field\_rotation[rotation]}$.

*** Abbildung mit Kraftvektoren in Konfigurationsraum ***


\subsection{Gradienten an Grenzen und Hindernissen}

Für Koordinaten an den $X$- und $Y$-Grenzen des Konfigurationsraums werden Kräften in Grenzrichtung in der jeweiligen Dimension auf $0$ gesetzt:
\begin{itemize}
\item $\texttt{force\_field\_x[0]} < 0$
\item $\texttt{force\_field\_x[occupancy\_grid\_width - 1]} > 0$
\item $\texttt{force\_field\_y[0]} > 0$
\item $\texttt{force\_field\_y[occupancy\_grid\_length - 1]} > 0$
\end{itemize}

Durch dieses manuelle "Abschneiden" der Kräfte -- das Setzen der Kraft auf $0$ -- können an den Grenzen lokale Minima oder Plateaus entstehen:
	*** TODO: Abbildung ***

Im Potenzialfeld \texttt{potential} haben Hindernisse das Potenzial \texttt{np.nan}. Somit berechnet \texttt{np.gradients()} für jede an ein Hindernis grenzende Koordinate den Gradienten \texttt{np.nan}.
Stattdessen sollen Hindernisse bei Berechnung der Gradienten wie Grenzen des Konfigurationsraums interpretiert werden. Ebenso wird hier die Kraft der jeweiligen Dimension auf 0 gesetzt, sollte negative Gradient in Richtung des Hindernisses zeigen. Beispiel für Hindernisse im Kraftfeld der X-Achse:

Kraftfeld			Koordinate Hindernis:	Gradient: 								Kraft = 0, wenn Kraft:
force\_field\_x		(x+1) => "rechts"		pot.[z, y, x] - pot.[z, y, x-1]			> 0
force\_field\_x		(x-1) => "links"		pot.[z, y, x+1] - pot.[z, y, x]			< 0
force\_field\_x		(x+1) und (x-1)			0										N/A
					=> "rechts und links"

Wird für eine Koordinate die Kraft einer Dimension "abgeschnitten", wobei die Kräfte der anderen Kraftfelder ebenfalls $0$ sind, entsteht ein lokales Minimum oder Plateau.


\subsection{Behandlung lokaler Maxima}

Im Unterschied zu einem lokalen Minimum oder Plateau ist bei einem lokalen Maximum das Potenzial der Nachbarn streng monoton niedriger als das der aktuellen Koordinate.
In diesen Fällen wird zu einem der Nachbarn eine virtuelle Grenze gesetzt und der Gradient wie im vorherigen Abschnitt beschrieben berechnet.

*** Abbildung mit Beispiel ***


\section{Gradientenabstieg}

Die berechneten Gradientenfelder ermöglichen die Roboternavigation durch das \textit{Gradientenabstiegsverfahren}:

Pro Verarbeitungsschritt wird für eine Koordinate $(\texttt{x},\texttt{x},\texttt{rotation})$ die nächste Koordinate basierend auf der beträgsmäßig größten Gravitationskraft in $F_{x}(\texttt{x}, \texttt{y}, \texttt{rotation})$, $F_{y}(\texttt{x}, \texttt{y}, \texttt{rotation})$ und $F_{rotation}(\texttt{x}, \texttt{y}, \texttt{rotation})$ gewählt, bis in einer Koordinate ein Kräftegleichgewicht $F_{x}(\texttt{x}, \texttt{y}, \texttt{rotation}) = F_{y}(\texttt{x}, \texttt{y}, \texttt{rotation}) = F_{rotation}(\texttt{x}, \texttt{y}, \texttt{rotation}) = 0$ herrscht:


\begin{algorithm}
\caption{Gradientenabstiegsverfahren}
\begin{algorithmic}[1]
    \State \textbf{Initialisierung:}
    \State \hspace{\algorithmicindent} $(\texttt{x}_{\text{current}}, \texttt{y}_{\text{current}}, \texttt{rotation}_{\text{current}}) = \texttt{start\_point}$
    \State \hspace{\algorithmicindent} Visited $V \leftarrow \emptyset$
	\vspace*{0.3cm}
    \While{true}
		\vspace*{0.1cm}
        \If{$(\texttt{x}_{\text{current}}, \texttt{y}_{\text{current}}, \texttt{rotation}_{\text{current}}) = \texttt{goal\_point}$}
            \State \textbf{return} Ziel gefunden
        \EndIf
		\vspace*{0.1cm}
        \State $\texttt{force\_field\_x/y/rotation}\texttt{[}\texttt{rotation}_{\text{current}}\texttt{][}\texttt{y}_{\text{current}}\texttt{][}\texttt{x}_{\text{current}}\texttt{]} = 0$
        \State $(\texttt{dx}, \texttt{dy}, \texttt{drotation}) \gets \max(|\texttt{force\_field\_x/y/rotation}\texttt{[}\texttt{rotation}_{\text{current}}\texttt{][}\texttt{y}_{\text{current}}\texttt{][}\texttt{x}_{\text{current}}\texttt{]}|)$
		\vspace*{-0.3cm}
        \If{$(\texttt{dx}, \texttt{dy}, \texttt{drotation}) = (0,0,0)$}
            \State \textbf{return} Lokales Minimum oder Plateau
        \EndIf
     	\vspace*{0.1cm}
        \State $(\texttt{x}_{\text{current}}, \texttt{y}_{\text{current}}, \texttt{rotation}_{\text{current}}) \gets (\texttt{x}_{\text{current}} + \texttt{dx}, \texttt{y}_{\text{current}} + \texttt{dy}, \texttt{rotation}_{\text{current}} + \texttt{drotation})$
		\vspace*{-0.3cm}
        \If{$(\texttt{x}_{\text{current}}, \texttt{y}_{\text{current}}, \texttt{rotation}_{\text{current}}) \in V$}
            \State \textbf{return} Lokales Minimum
		\Else
			\State $(\texttt{x}_{\text{current}}, \texttt{y}_{\text{current}}, \texttt{rotation}_{\text{current}}) \rightarrow V$
        \EndIf
		\vspace*{0.1cm}
    \EndWhile
\end{algorithmic}
\end{algorithm}

Der Gradientenabstieg muss dabei für die erlaubten Translationen des Konfigurationsraums diskretisiert werden: 
Gemäß der definierten Roboterbewegungen in Kapitel X (TODO!) darf der Roboter pro Verarbeitungsschritt nur eine Translation um eine Einheit entlang der Dimensionen \texttt{[rotation][y][x]} durchführen. Somit gilt:
\begin{equation*}
(\texttt{dx}, \texttt{dy}, \texttt{drotation}) \in \{(1,0,0)(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1)\}
\end{equation*}






